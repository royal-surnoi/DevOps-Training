### **Frontend** (What you see)
- The **frontend** is the part of an application you interact with directly. It's the design, buttons, text, and images you see on a website or app.
- Example: When you browse Amazon, the product pages, search bar, and cart are part of the frontend.
- **Built with:** Languages like HTML, CSS, and JavaScript.

---

### **Backend** (What works behind the scenes)
- The **backend** is the brain of the application. It processes what you do on the frontend and decides what to send back.
- Example: When you click "Buy Now" on Amazon, the backend processes your order, checks stock, and confirms payment.
- **Built with:** Languages like Java, Python, Node.js, PHP, etc.

---

### **Database** (Where data is stored)
- The **database** is like a storage room. It keeps all the information the app needs, like user details, product information, or orders.
- Example: Amazon’s database stores your account info, purchase history, and the list of products.
- **Built with:** Tools like MySQL, PostgreSQL, MongoDB, etc.

---

### How they work together:
1. You click a button on the **frontend** (e.g., "Search").
2. The **frontend** sends your request to the **backend**.
3. The **backend** checks the **database** for the info and sends it back to the **frontend**.
4. You see the results (like product suggestions).
-------
### **Types of Architecture in Software Development:**

1. **Monolithic Architecture**  
   - The entire application is built as a single unit.  
   - Example: A small app with frontend, backend, and database combined.  
   - **Why required?** Simple to develop and deploy for smaller applications.

2. **2-Tier Architecture**  
   - Separates the **frontend** (client) and **backend** (server).  
   - Example: A basic website where the frontend talks directly to a database.  
   - **Why required?** Improves separation and makes applications more organized.

3. **3-Tier Architecture**  
   - Separates the application into three layers: **frontend**, **backend**, and **database**.  
   - Example: A web app where the user interface interacts with a backend server, which talks to a database.  
   - **Why required?** Adds scalability, easier maintenance, and better security.

4. **Microservices Architecture**  
   - Breaks the application into smaller independent services that communicate with each other.  
   - Example: An e-commerce app with separate services for user authentication, product catalog, and payment processing.  
   - **Why required?** Increases flexibility, scalability, and ease of development for large applications.

---

### **3-Tier Architecture :**

- **Frontend:** The user interface (UI) that people interact with (e.g., website, mobile app).  
- **Backend:** The server-side logic that processes user requests and manages the app's functionality.  
- **Database:** Where all the data (e.g., user accounts, orders) is stored and retrieved from.

**Why 3-Tier?**
- Makes the application **scalable** (easier to handle more users).  
- Improves **security** by isolating the database.  
- Easier to **update** or **replace** any layer without affecting the others.


---

### **Microservices Architecture :**

- Instead of building one big application, you create **small, independent services**.  
- Each service does one thing well, like managing users, sending emails, or handling payments.  
- These services communicate with each other using APIs.

**Why Microservices?**
- Easier to **scale** specific parts of the app (e.g., only scale the payment service if it's heavily used).  
- Different teams can work on separate services without interfering.  
- Reduces the risk of a **single point of failure**—if one service crashes, others keep running.
